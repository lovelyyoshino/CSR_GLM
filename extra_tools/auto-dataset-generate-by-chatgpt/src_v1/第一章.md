# 第1章 ROS-智能机器人开端

机器人操作系统（Robot Operating Systems,
ROS）因其点对点设计、语言支持度广、集成度高、兼容性好、工具包丰富、免费且开源等特点，已经广泛运用于各类机器人上，如机械臂、无人机、无人小车等。机器人是一个多学科交叉的热门领域，要求开发者精通电子、控制、通讯、计算机、机械等多个方面。本文从其操作系统入手，深入浅出的介绍了机器人操作系统的有关概念及其在实际项目中的运用。

# ROS的节点（node）

### 1.1.1节点

节点（node）是ROS中最小的进程单元，其可以使用不同的客户图书馆（Client
Libraries）（如roscpp、rospy）来进行节点间的通讯，即使用不同的编程语言编写的节点之间可以相互通讯。从程序角度来看，节点是用不同语言编写的一个个执行文件，执行文件之间可以通过话题（topic）、服务（service）、参数（parameter）进行通讯。从目标功能来讲，节点是将一个复杂功能拆解成一个个小功能的功能块。这种分布式节点可以减少项目开发中的通讯问题，从而可以减少项目开发时间，提升开发者的开发效率。一个实际的机器人系统会包括多个节点，比如驱动摄像头获取实时图像的节点、对捕捉的图像进行处理的节点、处理传感器信息的节点等等。这样做不仅可以提升开发效率，而且还可以提高系统的容错率，即使系统中一个节点出现错误，整个系统还是可以继续运作下去。节点在系统中的名称必须唯一。

### 1.1.2 节点管理器

节点管理器（ROS
Master）是管理系统众多节点的控制器，其运行机制类似DNS服务器，当任意节点想要接入ROS系统时，该节点需要先在节点管理器进行注册与命名，之后节点管理器会将该节点接入整个ROS系统中，因此节点管理器里存储着ROS系统正在运行着的所有节点的信息，当节点内的信息出现了变化，节点管理器将更新变化的信息并将更新后的节点信息与其他节点通讯。此外，节点之间的通讯也是通过节点管理器作为中介相联系的。当一个ROS程序启动时，需要首先启动节点管理器，节点管理器会依次启动节点。节点管理器与节点的关系如图1-1所示。




### 1.1.3 与节点有关的指令

（1）**ros-tutorials程序包的预安装**

首先，我们可以通过在Ubuntu系统中右击并点击打开终端（E）打开一个新的终端，又或者可以通过快捷键Ctrl+Alt+T来打开终端。终端打开的界面如图1-2所示。




在终端输入以下命令

    sudo apt-get install ros-<distro>-ros-tutorials

将指令中的distro替换为你ros的安装版本（如melodic、indigo、jade、kinetic、noetic、hydro、groovy等）

（2）**roscore命令**

打开一个新的终端并在终端输入如下指令

    roscore

在终端中运行出的结果如图1-3所示




其中ros_comm version与 \*/rosversion
都是显示当前ros的版本号，而rosdistro则显示的是当前你安装的ros系统的版本。

在运行ROS系统前必须先执行该指令以启动节点管理器，该指令执行后rosout节点和parameters
server框架会一起启动，其中rosout节点是所有工作节点都自带的一个节点，用于收集和记录节点调试输出信息，而parameters
server则不是节点，是方便分布式并行程序编写的编程框架，用于系统参数的配置。

如果roscore的初始化失败，则可能是网络配置出现异常导致的。如果初始化失败并且发送了缺少允许的消息，可能\~/.文件夹被root所占有，可以通过下列指令来修改这一文件的占有权来解决这一问题

    sudo chown -R <your_username> -/.ros

（3）**rosrun命令**

由上述内容可以知道，节点是ROS系统中最基础的执行单元，所以我们需要了解如何去运行一个节点。其输入指令格式如下

    rosrun [package_name] [node_name]

该指令可以直接运行已知路径的节点，其中package_name是节点所在功能包的名字，而node_name是需要运行的节点名。本文以ROS自带的小乌龟节点作为示例，在终端输入如下命令

    rosrun turtlesim turtlesim_node

打开的小乌龟窗口如图1-4所示




由于ROS每次产生一个版本都会创建一个小乌龟作为代表，打开小乌龟模拟时小乌龟是随机产生的，所以每个人打开的乌龟可能颜色和种类会存在一些差异。

成功运行小乌龟节点之后我们打开一个新的终端并输入以下命令

    rosrun turtlesim turtle_teleop_key

出现图1-5界面时，我们可以通过键盘来控制小乌龟的移动。




（4）**rosnode命令**

因为ROS系统的功能都是由一个个节点一起组合构成的，所以我们需要及时掌握每一个运行着的节点消息，ROS系统中与节点有关的命令如表1-1所示

  -------------------------------------------------------------------------
  命令                       说明
  -------------------------- ----------------------------------------------
  rosnode list               查看所有正在运行的节点列表

  rosnode ping \[node_name\] 测试指定节点是否正常运作

  rosnode info \[node_name\] 查看指定节点的信息

  rosnode machine            查看该PC机中运行的节点列表
  \[PC_name\]                

  rosnode kill \[node_name\] 停止该节点的运行

  rosnode clean up           删除所有没有连接节点在节点管理器中的注册信息

  rosnode help               查看rosnode命令的具体用法
  -------------------------------------------------------------------------

表1-1 与node相关的一些命令

下面对这些节点命令进行示例讲解

（5）**rosnode list命令**

在上述运行小乌龟及其键盘控制节点的情况下打开一个新的终端，并在新终端中输入以下命令

    rosnode list

可得到如图1-6所示的消息列表返回




在图中可以发现运行着的节点有/rosout
、/turtlesim、/teleop_turtle,其中注意到运行小乌龟的节点名/turtlesim，而用键盘控制小乌龟移动的节点名为/teleop_turtle，这与我们用rosrun命令执行的节点名称存在些许差别。以控制节点为例，在运行rosrun命令时我们需要的是该节点文件的名字，而rosnode
list
指令显示的是该节点实际向节点管理器注册的节点名。我们找到键盘控制命令的源文件间发现其初始化代码为"ros::init(argc,
argv,
"teleop_turtle");"所以该节点文件实际向节点管理器请求的注册节点名是/teleop_turtle。我们可以通过以下指令来修改在ROS系统中的实际节点名。

    rosrun [package] [node_name] _name:=[node_name_want]

其中node_name_want 是你向该节点输入的参数

关闭/teleop_turtle的终端我们后重新打开一个新的终端并在新终端输入以下命令

    rosrun turtlesim turtle_teleop_key __name:=control

此时，若我们重新执行rosnode
list命令，便能得到如图1-7所示的结果。我们发现相较于之前的输出，节点/teleop_turtle被我们替换成了自己定义的节点/control。




重新映射命令不仅能够对节点的名称进行替换，也可以对私有节点的参数进行相应配置

（6）**rosnode ping命令**

我们在上面成功的将节点/teleop_turtle替换为节点/control，现在我们要测试该节点是否被正常启动，能否正常运作，我们需要用到节点测试命令rosnode
ping，在终端输入如下指令。

    rosnode ping /control

如果该节点与当前计算机连接正常，结果如图1-8所示



图1-8节点测试界面

（7）**rosnode info命令**

在ROS系统中我们有的时候会对系统一些节点的具体信息及其在整个系统中的作用不是特别明确，此时我们想了解其相关信息就需要用到rosnode
info命令，在终端中输入如下命令。

    rosnode info /turtlesim

我们会得到该节点的具体信息如图1-9所示。




其中Publications显示其发布的话题名及其路径，Subscriptions显示其订阅的话题名及其路径，Service是其包含的服务内容，Connections显示的则是其通讯机制。

(8）**rosnode machine命令**

该指令可以显示指定目标上所有正在运行的节点，该命令可以说是rosnode
list命令的一个延展，此命令不仅可以查看本机上运行的节点，也可以显示与其相连接其他PC机上运行的节点。其输入命令格式如下所示。

    rosnode machine [IP address/PC name]

运行该指令的结果如图1-10所示。




（9）**rosnode kill命令**

该命令可以用于终止指定节点的运行，在终端中输入如下命令又或者通过快捷键Ctrl+C来终止在该终端运行着的节点

    rosnode kill /turtlesim

得到结果如图1-11所示。



1-11 终止进程界面。

我们重新运行rosnode list命令查看此时系统运行的节点结果如图1-12所示。



1-12 节点显示界面

此时可以发现节点/turtlesim成功在ROS系统中被终止运行了。

（10）**rosnode cleanup命令**

该命令用于删除连接信息丢失的虚拟节点在节点管理器注册的信息。在ROS系统运行的过程中我们总会由于一些特殊原因导致节点的异常终止，此时我们可以用该命令来删除这些因为系统异常而终止的节点。该命令最直观的好处是当系统因为一些具体节点异常导致整体异常时，我们只需要先删除这些节点的注册信息并重新运行该节点即可，而不用再一次重新运行一遍roscore命令和一堆节点。该命令的输入格式如下所示

    rosnode cleanup

# 1.2 ROS命令指令与使用

在上一节我们已经学习了ROS系统中与节点有关的相关命令，而ROS系统中还存在着话题和服务这两种通讯机制，我们将在本章节学习与其相关的一些列命令及其演示。

### 1.2.1与msg相关的命令

ROS系统中提供了rosmsg命令以令使用者更好的对系统内的msg文件进行操作，即我们可以用该类命令对于话题类型中的数据结构进行查看，我们打开一个新终端在其中输入如下命令已查看其具体使用方式

    rosmsg --h




其所有命令如图1-13所示。下面我们将对部分命令做相关解释和使用示例。

**（1）rosmsg show命令**

该命令用于查看.msg类型文件的数据类型，其一般使用格式如下所示

    rosmsg show [package_name]/[msg_name]

其中package_name为目标msg文件所在功能包的名字，msg_name则为对应msg文件的名字，我们以ROS
自带的std_msg功能包中的string文件为例在新建立的终端中输入以下命令。

    rosmsg show std_msgs/String

我们看到String文件里面的数据内容如图1-14所示




该命令反馈String文件内的数据类型为 string
data型。有的时候我们可能只知道消息名而不知道其对应的功能包名字，此时我们也可以用该命令进行寻找。同样以String文件为例，我们只需要将上述命令中的功能包名字删除即可，终端中输入命令如下

    rosmsg show String

可以得到其对应功能包位置及文件包含的数据类型如图1-15所示




**（2）rosmsg list命令**

该命令可以用于列出ROS系统中所有与话题通相关的数据结构，包括官方的和自己自定义的数据类型，其命令如下所示

    rosmsg list

在终端输入该命令得到的信息如图1-16所示，但该结果中包含了大量我们不需要关注的信息，且很难在其中寻找需要的消息，所以我们一般不怎么用该命令。




**（3）rosmsg package命令**

因为使用rosmsg
list去寻找需要的话题类数据结构过于繁琐所以我们可以使用rosmsg
package命令来缩小寻找的范围，从而简化搜索过程。其命令格式如下所示。

    rosmsg package [package_name]




其显示结果如图1-17所示，该命令显示了std_msgs功能包路径下的所有话题类数据结构文件。

rosmsg
package命令还可以用来寻找所有包含话题类数据结构文件的功能包，其命令输入如下所示。

    rosmsg packages

该命令显示效果如图1-18所示，将所有符合的功能包一行一行的列出来。




### 1.2.2与topic相关的命令

话题是ROS中最常用的基本通讯方法之一，下面我们来介绍与话题有关的命令。我们在新的终端中输入以下命令以查看与话题相关的详细命令

    rostopic --h




其相关命令如上图1-19所示，下面我们来对具体命令及其示例做出解释。

**（1）rostopic list命令**

该命令与上一章节的rosnode
list命令相似，用于显示正在运行节点的话题名称，在终端输入以下命令

    rostopic list




我们得到的结果如图1-20所示，我们从中得知此时只有两个话题正在运行，其中话题rosout用于记录和收集节点的调试输出信息，而话题rosout_agg则是所有rosout消息的汇集，有利于减少调试的开销。

如果我们需要更加详细的知道话题的信息，我们可以使用如下命令

    rostopic list -v




其结果如图1-21所示，相较于rostopic
list命令，该命令显示了发布者/订阅者与该话题的关系，显示的话题消息更加详尽。

有时我们可能只需要知道某个命名空间下的话题，则可以用如下命令

    rostopic list [namespace]

其中\[namespace\]为创建的命名空间的名字。

以上一章节的小乌龟为例我们先创建一个小乌龟进程之后并在新的终端输入如下命令。

    rostopic list /turtle1




得到的结果如图1-22所示，我们在新创建的命名空间/turtle1中得知存在三类话题，分别是小乌龟速度/cmd_vel、小乌龟的颜色/color_sensor、小乌龟的位置/pose。

（2）**rostopic bw命令**

该命令中的bw实质上是英文单词"bandwidth"（带宽）的缩写，所以该命令是用来显示两个节点间指定话题的带宽，即两节点之间的通信速度（单位:bit/s）。该命令的格式如下所示。

    rostopic bw [topic_name]

我们以上一章通过键盘来控制小乌龟的移的进程为例来讲解该指令的使用示例。在终端中分别运行turtlesim_node与turtle_teleop_key节点后在新终端中输入如下命令

    rostopic bw /turtle1/cmd_vel

在执行该进程时，我们需要选中turtle_teleop_key节点并通过键盘来移动小乌龟，此时得到的两个节点间话题的带宽如图1-23所示。




途中数据显示了该话题的通信速率，其单位为比特每秒，其中window则表示从开始通信到目前位置一共通信了多少次。

**（3）rostopic delay命令**

该指令可以通过捕捉.h头文件来显示话题的延迟，其使用格式如下图所示。

    rostopic delay [topic_name]

由于rostopic
delay需要在通讯过程中捕捉.h文件，所以本章节并不对其进行示例，当运行的话题不存在.h头文件时该命令无效，其显示消息如下所示。

    [ERROR] [1651506129.451847]: msg does not have header

**(4) rostopic pub命令**

该命令用于向话题发布信息，其使用格式如下所示。

    rostopic pub [topic_name] [msg_type] [args]

其中msg_type为该消息的数据类型，args为该消息的具体内容。

以小乌龟的控制话题为示例，在向话题/turtle1/cmd_vel发布消息前我们需要使用rostopic
list -v命令来获取话题的订阅者，得到结果如图1-24所示。




我们得知话题名为/turtle1/cmd_vel，话题类型为geometry_msgs/Twist，至于其话题内容我们可以使用tab键来自动补全并将其中一些参数进行修改，在终端输入的命令如下。

    rostopic pub /turtle1/cmd_vel geometry_msgs/Twist "linear:
      x: 1.0
      y: 1.0
      z: 0.0
    angular:
      x: 0.0
      y: 0.0
      z: 0.0"

其中linear：x、y、z代表着三轴的线速度，而angular：x、y、z代表三轴的角速度，小乌龟的移动如图1-25所示。




从上图中我们发现小乌龟往x轴和y轴各自移动了一个单位，与我们输入的命令结果一致。

rostopic
pub命令可以通过不同的后缀取得不一样的效果，其格式和效果如表1-2所示。

  ------------------------------------------------------------------------
  输入命令的格式   说明
  ---------------- -------------------------------------------------------
  rostopic pub -l  Latch模式（默认模式），只发布一次消息

  rostopic pub -r  Rate模式，按照指定频率发布消息

  rostopic pub -1  Once模式，发布完一次消息后自动退出

  rostopic pub -f  Filter模式，publisher从yaml文件中读取消息然后进行发布
  ------------------------------------------------------------------------

表1-2 rostopic pub命令的各种模式

下面以-r和-1为例，来介绍两种模式的具体使用方法。

在终端中输入以下命令来实现pub命令的Rate模式。

    rostopic pub -r 10 /turtle1/cmd_vel geometry_msgs/Twist "linear:
      x: 1.0
      y: 0.0
      z: 0.0
    angular:
      x: 0.0
      y: 0.0
      z: 1.0"




我们的得到的结果如图1-26所示，小乌龟做圆周运动，终端以10hz的频率向小乌龟发布运动消息，与上述输入的命令一致。

在终端中输入以下命令来实现pub命令的Once模式。

    rostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist "linear:
      x: 1.0
      y: 0.0
      z: 0.0
    angular:
      x: 0.0
      y: 0.0
      z: 1.0"




得到结果如图1-27所示，Once模式下终端会持续发布3s，3s后该命令会自动退出。

（5）**rostopic hz命令**

该命令用于查询话题发布消息的速度，其使用方式如下所示

    rostopic hz [topic_name]

因为本命令用于查询话题发布的速度，所以我们需要对/turtle1/cmd_vel这一话题持续发布消息，所以我们先运行rostopic
pub
-r这一命令，并将发布频率设置为10hz。做完准备工作之后在新的端口输入以下命令

    rostopic hz /turtle1/cmd_vel




得到结果如图1-28所示，我们发现话题发布频率大致在10hz左右，与我们发布的话题频率相符合。

**（7）rostopic info命令**

该命令用于查看指定话题中通讯双方的信息，即订阅者和发布者，其命令格式如下所示。

    rostopic info [topic_name]

我们以小乌龟的移动为示例，打开小乌龟移动仿真之后在新的终端输入以下命令。

    rostopic info /turtle1/cmd_vel




其结果如图1-29所示，在图中我们得知/turtle1/cmd_vel这一话题的发布者为/teleop_turtle,即是我们打开的键盘控制小乌龟运动的节点，而其订阅者为/turtlesim，即是我们打开的小乌龟节点。

**（8）rostopic type命令**

该命令用于查询指定话题的数据类型结构，其使用格式如下所示。

    rostopic type [topic_name]

同样以小乌龟节点为例，我们在终端输入以下命令，来查询/turtle1/cmd_vel话题中数据类型结构。

    rostopic type /turtle1/cmd_vel



图1.1.2.17 /turtle1/cmd_vel话题的数据类型结构


得到的结果如图1-30所示，其数据类型结构为geometry_msgs/Twist，与我们在之前用msg_type命令得出的结果相符。

**（9）rostopic echo命令**

该指令用于显示发布到指定话题终端的消息，其使用格式如下所示

    rostopic echo [topic_name]

同样是以键盘控制小乌龟为例，我们在新终端中输入以下命令后，控制小乌龟移动。

    rostopic echo /turtle1/cmd_vel




得到的结果如图1-31所示，其显示内容为我们用键盘移动小乌龟发布的消息为三轴的线速度和角速度。

如果我们觉得每发布一次消息该终端就会显示一条消息过于麻烦，我们也可以用以下命令使其每发布一次消息就会自动清屏并自动显示下一跳消息。

    rostopic echo -c /turtle1/cmd_vel

其结果如图1-32所示




### 1.2.3与service相关的命令

上一节我们介绍了与话题相关的命令，现在我们来介绍ROS系统中的另一个通讯机制---服务（service）的相关命令，我们在终端输入以下命令查看与其有关的命令。

    rosservice --h




得到的结果如图1-33所示，下面我们将对这些命令行和示例做出解释

**（1）rosservice list命令**

该命令用于显示所有正在运行的服务，我们在终端输入如下命令。

    rosservice list




得到结果如图1-34所示，在图中我们可以找到所有正在运行着的服务，这些服务端的服务对象是我们之前执行的小海龟仿真器，而客户端则是我们的终端，整个服务的流程是我们通过终端请求服务，而这些服务的对象则是小海龟仿真器。

**（2）rosservice call命令**

该命令用于调用服务，其使用格式如下所示。

    rosservice call [service_name] [args]

以/spawn服务为例，该服务的作用是在小乌龟仿真器中生成一个新的小乌龟，在终端中输入的命令如下所示，同样对于参数部分可以运用Tab快捷键进行补全。

    rosservice call /spawn "x: 0.0
    y: 0.0
    theta: 0.0
    name: ''" 




得到的结果如图1-35所示，执行玩该命令后小乌龟仿真器在坐标（0,0）出生成了一个角度为0°的小乌龟，，系统自动将其命名其为"turtle2"，这也体现了服务具有反馈的特点，该结果与我们call命令中输入的参数一致。此时重新调用rostopic
list命令我们会发现生成的"turtle2"小乌龟也包含了"turtle1"中的各类话题。

**（3）rosservice info命令**

该命令与rostopic info类似都是查看对象的信息，只不过rosservice
info命令是查看的服务的相关信息，其使用格式如下所示

    rosservice info [service_name]

以rosservice
list命令寻找出的/turtle1/set_pen服务为例，在终端中输入如下命令。

    rosservice info /turtle1/set_pen




得到结果如图1-36所示，从图中我们可以知道该命令显示了与该服务有关的节点的名称、URI（Uniform
Resource Identifier，统一资源标识符）、服务类型和其包含的参数。

**（4）rosservice type命令**

该指令用于显示指定服务的服务类型，其使用格式如下所示。

    rosservice type [service_name] 

同样以之前选择的/turtle1/set_pen服务为例，在终端中输入以下命令。

    rosservice type /turtle1/set_pen




得到的结果如图1-37所示，从图中我们得到该服务的类型是turtlesim/SetPen，与rosservice
info命令得出的结果相符合。

**（5）rosservice find命令**

该命令与rosservice type命令刚好相反，rosservice
type命令是通过服务来显示服务类型，而rosservice
find则是通过服务类型寻找服务，其使用格式如下所示。

    rosservice find [service_type]

以上一节得到的服务类型turtlesim/SetPen为例，在终端输入如下命令。

    rosservice find turtlesim/SetPen




得到的结果如图1-38所示，该图显示出了包含turtlesim/SetPen服务类型的所有的服务，我们在小乌龟仿真器上创建的两个小乌龟内包含了该类型的服务。与上节结果一致。

**（6）rosservice args命令**

该命令用于显示指定服务内的参数，其使用格式如下所示。

    rosservice args [service_name]

同样以/turtle1/set_pen服务为例，在终端中输入以下命令

    rosservice args /turtle1/set_pen




得到结果如图1-39所示，图中得知/turtle1/set_pen服务中包含的参数与rosservice
info命令得出来的结果相一致。

### 1.2.4消息记录与回放命令

下面我们将介绍ROS中用于记录与复现话题的工具---rosbag，该命令可以记录你当前所有话题中的数据，并在之后需要这段数据时，可以重新复现出该次数据。该工具可以用于记录一些无人设备的户外实际数据，并重新在实验室内对这段数据进行处理，而不是在实验室内重新进行数据的采集。

（1）**rosbag record命令**

该命令用于保存话题消息，其使用格式如下所示。

    rosbag record -O subset <topic1> <topic2>...

下面我们以控制小乌龟的移动为例，介绍该命令的使用，运行完键盘控制小乌龟运动节点后在新的终端中输入以下命令。

    rosbag record -a -O cmd_record

其中-a表示记录所有话题信息，而-O则是为了对生成的bagfile文件进行预命名，方便寻找，系统默认的命名是以日期和时间为准的命名方式。




得到结果如图1-40所示，可以按快捷键Ctrl+C来终止该进程，该命令生成的bagfile会保存在当前终端默认的路径下面，其命名为cmd_record.bag。

**（2）rosbag info命令**

该命令用于显示bagfile文件的信息，其使用格式如下。

    rosbag info [bagfile_name]

以rosbag
record命令创建的cmd_record.bag文件为例介绍该命令的用法，在终端输入的命令如下所示。

    rosbag info cmd_record.bag




结果如图1-41所示，该命令显示了该文件的具体内容。

**（3）rosbag play命令**

该命令用于复现bagfile存放的内容，其使用格式如下所示。

    rosbag play (-r 2) [bagfile_name]

其中（-r
2）可以让bagfile里面记录的消息以2倍速的方式复现，打开小乌龟仿真器后在新的终端中输入如下命令。

    rosbag play cmd_record.bag




其结果如图1-42所示，该命令将之前用rosbag
record命令记录的动作重新复现了。

**1.1.2.6故障诊断命令**

在使用ROS开发项目中我们会遇到一些问题，而项目开发中寻找问题是一件比较麻烦的事情，需要耗费大量的时间和精力去一一排查，ROS中就提供了roswtf工具让我们来检查ROS系统是否正常工作。

**（1）检查master是否启动或者运行成功**

我们在不运行roscore的状况下去输入以下命令

    roswtf




结果如图1-43所示，因为系统没有运行roscore命令，即没有ROS
master，所以会提示没有。

**（2）在线检查**

这次在运行完roscore命令后再输入该命令




其结果如图1-44所示，发现roswtf回馈出一个警告，/rosout节点只有订阅，而无信息发布。因为我们没有运行任何其他节点，所以会有该警告。

# 1. 3 工作空间与功能包的创建

在开始学习创建自己的工作空间之前我们要先了解ROS系统的文件分级，ROS的文件与Windows操作系统类似，都是以一种特定方式存在于一个个文件夹内，每一个文件内我们都可以看到对应的文件，ROS系统的文件分级结构如图1-45所示。




对应的文件分级模块概念如下：

**工作空间**（Workspace）：工作空间是用来存放项目所需的工程文件的文件夹，主要包含src（代码空间）、build（编译空间）、devel（开发空间）、install（安装空间）这四个文件，其中src文件主要用于存放各类功能包和CMakeList，build文件主要用于存放编译工程中产生的编译文件，devel文件主要用于存放开发过程中产生的一些可执行文件和库文件，install文件主要用于存放项目最后生成的可执行文件。其中devel和install的功能类似，都是用于存放可执行文件，其区别是在于devel用于项目开发中，而install则用于放置最终生成的可执行文件。同一个工作空间下，不允许存在同名功能包。不同工作空间下，允许存在同名功能包。

**功能包**（Package）：功能包是ROS系统中最基础的单元，每一个功能包都包含了库文件、节点、配置文件（CMakeLists.txt）、功能包清单（Package.xml）和其功能包所需要的所有文件。功能包是一个ROS系统最底层的构建者和消息的发布者。

**元功能包**（Meta
Package）：元功能包是一系列功能包的组合，这些功能包共同作用构成了一个完整的功能。其内部还包含了元功能包的属性文件，与功能包属性文件类似，但元功能包属性文件包含了元功能包内部所有功能包的依赖并导出一个标签。

**信息文件**（msg）：信息文件是ROS节点之间进行通讯的一种格式，我们可以在msg文件夹中存放我们需要的信息文件，其尾缀为.msg。

**服务文件**（srv）：服务文件也是ROS节点之间进行通讯的一种格式，但与信息文件不同的是，服务文件存在要求和回复，我们可以在srv文件夹中存放我们需要的服务文件，其尾缀为.srv。

### 1.3.1 工作空间和功能包的组成

一个功能齐全的功能包需要包含如下组成，提供各种功能包编译信息的功能包清单文件（package.xml）、包含了编译规则的配置文件（CMakeLists.txt）以及包含各类节点的功能包文件夹。一个简单的功能包的结构如下所示

    package/
      CMakeLists.txt
      package.xml
      src

虽然也可以分开来创建各个功能包，但为了更加简化项目开发过程，我们推荐将所有需要的功能包都放在工作空间内，创建的工作空间的结构如下所示

    catkin_ws/
      build
      install
      devel
      src/
        CMakeLists.txt
        package_1/
          CMakeLists.txt
          package.xml
        ...
        package_n/
          CMakeLists.txt
          package.xml

### 1.3.2 工作空间的创建

下面我们来创建工作空间，在终端输入以下命令来创建工作空间。

    mkdir -p ~/catkin_ws/src
    cd ~/catkin_ws/src
    catkin_init_workspace

其中mkdir命令为建立一个新的目录，其中的catkin_ws可以根据项目需求对其进行修改，而src是表示代码空间，则不可以进行修改。cd命令则是将终端的路径转移到了src文件夹中，为下一步初始化做准备。catkin_init_workspace命令则是对代码空间（src）进行初始化，使其具有ROS的属性，会在代码空间生成一个用于编译的CMakeLists.txt文件，表明当前路径已经是ROS系统中的工作空间，且即使该文件夹是空的也可以使用该命令对其属性进行修改。指令运行正确时/src路径下的文件如图1-46所示。




### 1.3.3 编译工作空间

下面我们用输入如下命令完成工作空间的编译

    cd ~/catkin_ws/
    catkin_make

因为catkin_make命令必须要在与src同级的目录下进行，所以我们在终端执行该命令前需要运用cd命令将当前目录转移到/catkin_ws下。catkin_make命令用于编译当前建立好的ROS的工作空间，该命令与上一节初始化命令catkin_init_workspace相似，即使是空文件都可以执行，执行完该命令后我们可以得其结果如图1-47所示




在该图中我们发现工作空间中只生成了devel和build文件，缺少install文件，我们需要在终端输入如下命令来生成install文件。

    catkin_make install

其结果如图1-48所示




其中install（安装空间）用于存放项目最后编译生成的可执行文件，其内部文件如图1-49所示。




devel（开发空间）与install相似都是用于存放生成的可执行文件，但devel主要用于存放开发过程中生成的可执行文件，其内部文件如图1-50所示。




build（编译空间）主要存放编译过程中的一些二进制的文件，因为可读性很差，所以基本上用不到，其内部文件如图1-51所示。




### 1.3.4 设置环境变量

我们每次在编译之后，都要执行该命令，其目的是让ROS系统能够找到该工作空间及其内部对应的功能包，其使用格式如下所示

    source devel/setup.bash

### 1.3.5 检查环境变量

当我们找不到工作空间位置时，我们可以运行如下命令来寻找其路径

    echo $ROS_PACKAGE_PATH

其结果如图1-52所示




从图中我们得知/home/ubuntu/catkin_ws/src为我们目前的工作空间的路径。

### 1.3.6 功能包的创建

创建完成工作空间后我们需要在工作空间里创建我们需要的功能包，创建功能包的命令如下所示。

    catkin_create_pkg [package_name] [depend1] [depend2]

其中depend为你功能包需要的依赖及依赖库，如std_msgs是ROS里面定义了各类数据类型化的标准信息结构库、roscpp是C++语言需要的依赖库、rospy是Python语言需要的依赖库。同一个工作空间下，不允许存在同名功能包，但是在不同工作空间下，允许存在同名功能包。功能包的创建必须在代码空间src目录下。下面我们在终端输入以下命令来创建我们的第一个功能包。

    cd ~/catkin_ws/src
    catkin_create_pkg learning std_msgs rospy roscpp

此时终端反馈如图1-53所示。




创建成功之后我们进入到src文件里的learning，我们得到结果如图1-54所示




其中src文件夹用于存放功能包里的代码文件，比如.cpp、.py文件，include文件则是用来存放如.h文件的头文件，系统还自动生成了CMakeLists.txt和package.xml文件。功能包创建成功后我们还需要对工作空间重新进行编译，在终端输入如下命令。

    cd ~/catkin_ws
    catkin_make
    source devel/setup.bash

编译成功的界面如图1-55所示




因为配置环境变量命令需要每次编译后都要输入一遍，在进行复杂ROS项目开发的时候经常会忘记配置环境变量，从而增加不必要的工作量，为了避免上述情况的发生，我们只要将该命令拷贝到.bashrc文件中。该文在主文件夹中以隐藏文件的形式存在，我们可以通过快捷键Ctrl+h来显示隐藏文件。其结果如图1-56所示。




打开该文件在该文件的最下面增加路径配置，但是我们需要对其的路径进行补全，根据路径和用户名补全的内容如下图所示，值得注意的一点是.bashrc文件在source多个项目时，有时只会source最后一个，如果不确定还是使用source
devel/setup.bash会比较好。其结果如图1-57所示。




其中ubuntu为用户名，需要根据自己的用户名进行修改。

### 1.3.7 package.xml文件内容

该文件是运用xml语言来定义有关软件包的属性，例如软件包的格式，名称，版本号，描述，维护者信息以及对其他catkin软件包的依赖。以learning功能包中的package.xml文件做示例。其内容如图1-58所示。




软件包的具体属性如上图所示，其中\<package
format=\"2\"\>表示该功能包选用格式2；\<name\>learning\</name\>表明了该功能包的名称；\<version\>0.0.0\</version\>表明了该功能包的版本号；\<description\>The
learning package\</description\>则是该功能包的具体作用；\<maintainer
email=\"ubuntu@todo.todo\"\>ubuntu\</maintainer\>提供了维护者的邮箱的地址信息，方便使用者与维护者的联系；\<license\>TODO\</license\>则表示了该功能包的开源许可证。这一部分消息主要是告知使用者该功能包的具体信息。

该功能包的具体依赖如图1-59所示




该部分的依赖由创造该功能包时所添加的依赖和依赖库有关，其中\<buildtool_depend\>catkin\</buildtool_depend\>表示编译工具为catkin；\<build_depend\>roscpp\</build_depend\>等命令用于寻找构建该功能包需要的依赖；\<build_export_depend\>roscpp\</build_export_depend\>等命令用于寻找构建该功能包库时所需要依赖的库；

\<exec_depend\>roscpp\</exec_depend\>等命令则是执行该程序包中代码所需要的程序包。

以上依赖在对工作空间进行编译的时候，ROS系统会去一一寻找，如果没有找到指定的依赖，编译会出现报错。当我们之后需要新的依赖时，可以通过在里面添加这些语句来进行。

### 1.3.8 CMakeLists.txt文件作用

该文件是用CMake语法构建的用于描述功能包编译规则的软件包。任何兼容CMake的软件包都包含一个或者多个CMakelist.txt文件，这些文件描述了如何构建代码以及将代码安装到何处。同样以创建的learning功能包里面的CMakelist.txt文件为例，其内容如图1-60所示。




其中cmake_minimum_required(VERSION
3.0.2)表示编译所需要的cmake的版本为3.0.2、project(learning)是该功能包的名称，可以用
\${PROJECT_NAME}
的方式来调用、find_package()里面包含的则是系统所需要的依赖，这些依赖是在创建该功能包时声明编译后产生的，如果之后需要新的依赖直接在其中添加新的依赖即可。

如果需要添加Boost库只需要将图1-61所示语言前的#号删除，即可调用该库




当我们需要使用自己定义的Topic、Service、Action时则需要使用图1-62所示的部分




其中add_message_files()、add_service_files()、add_action_files()可以使catkin添加宏，添加自定义的message文件、service文件和action文件，而generate_messages（）可以令catkin添加宏，生成不同语言版本的msg/srv/action接口。




图1-63为catkin_package()的使用方式，该语言可以在catkin添加宏，生成当前package依赖的cmake配置，供依赖本包的其他软件包调用，举例来讲如果本功能包通过在DENPENDS中使能roscpp，生成了roscpp的cmake配置，当其他功能包依赖本功能包时，就不需要find_package(roscpp)，但在实际开发项目时，并不建议这么做，因为当另一个功能包在单独编译是会出因为功能包的缺失而造成编译错误。




图1-64为本功能包与build有关的编译指令，其中include_directories()用于指定C++的头文件路径、add_library()用于生成C++库、add_dependencies()用于与自定义的msg与srv相链接、add_executable()用于生成可执行的二进制文件、target_link_libraries()用于C++接口与ROS库的链接。




与install有关的语言如图1-65所示，install ()用于安装至本机。




与test相关的语言如图1-66所示，catkin_add_gtest()可以在catkin添加宏，生成测试。

# 1.4 可视化参数指令(Parameter)的使用

本节我们将学习ROS中参数命令的使用、静态调整参数与动态调整参数。在之前的学习中，我们发现在启动ROS
Master这一节点管理器时，随之一起启动的还有/rosout节点和Parameter
Server（参数服务）。ROS系统中参数模型如图1-67所示。




其中参数模型是一个全局字典，其用于保存配置参数，以小乌龟程仿真器为例，该参数用于存放小乌龟的名字，小乌龟的速度，小乌龟的位置等信息。如果Node1想要获取小乌龟的名字，则其只需要向ROS
Master发布查询/turtlesim_name的请求，这样Node1会得到来自Parameter
Server的反馈。即使是位于不同PC上的节点，只要其处于同样的ROS环境中，都可以通过Parameter
Server来获取其中保存的参数。我们可以将其当成一个可以存储全局变量的存储空间。

### 1.4.1 Parameter Server的使用

**（1）与parameter相关的命令**

ROS中提供了一些与参数有关的命令，方便我们对于参数进行查询和修改，我们打开一个新终端在其中输入如下命令以查看其具体使用方式。

    rosparam 




其结果如图1-68所示，下面我们将对一些命令做一些解释和使用示例。

**（2）rosparam list命令**

该命令用于列出目前在Parameter
Server存放的配置参数，使用该命令前，为了增加可以修改的参数，需要提前运行小乌龟仿真器，之后在终端输入如下命令。

    rosparam list

其结果如图1-69所示




其中/background_b、/background_g、/background_r，分别为运行的小乌龟仿真器背景的蓝色、绿色和红色的色度，/rosdistro为系统的ROS版本号、/rosversion为当前ROS的版本、/run_id为该进程的id号、其中前面四个参数是随着ROS
Master的启动而生成的，而后三者则是对应的小乌龟模拟器的参数。

**（3）rosparam get命令**

在知道了当前系统包含的参数后，需要使用rosparam
get命令来获取对应参数里面的内容，其使用格式如下所示。

    rosparam get [parameter_name]

以用rosparam list命令寻找到的参数/background_b为例，在终端输入如下命令。

    rosparam get /turtlesim/background_b
    rosparam get /turtlesim/background_g
    rosparam get /turtlesim/background_r
    rosparam get /rosdistro
    rosparam get /rosversion




得到的结果如图1-70所示，我们得到的蓝色的值为255，绿色值为86、红色的值为69、ROS系统的版本号为melodic、版本为1.14.13.

**（4）rosparam set命令**

在执行ROS系统的时候有时需要对一些参数值做对应的修改，ROS系统中提供了对应的rosparam
set命令来对参数值进行静态调整。其使用格式如下所示

    rosparam set [parameter_name] [value]

下面对/turtlesim/background_b参数值进行调整，将其调整为0，在终端中输入如下命令

    rosparam set /turtlesim/background_b 0
    rosparam get /turtlesim/background_b

其结果如图1-71所示




此时查看小乌龟仿真器，发现其结果没有变化，因为此时系统还没有刷新参数值，需要调用服务来刷新参数值，在终端输入如下命令。

    rosservice call /clear

其中/clear服务用于清除小海龟的所有的移动路径，并根据现在的参数值重新刷新仿真器的状态。得到的结果如图1-72所示。




在上图中发现小海龟的背景色发生了改变，原因是将蓝色值变为了0，并且背景色绿色的色度大于红色的色度，所以背景更偏向绿色。

**（5）rosparam dump命令**

如果希望将目前所有的参数保存下来作为之后调试的一个依据，ROS提供了参数保存命令，其格式如下所示

    rosparam dump [file_name] 

一般保存参数的文件类型是.yaml类型，在终端中输入如下命令。

    rosparam dump params.yaml

一般该文件存储于对应的主目录下其文件内部消息如图1-73所示




从图中可得知该文件将系统的参数成功的以yaml格式被记录在了文件内。

**（6）rosparam load命令**

在上一节中学习了如何将所有参数保存在一个.yaml文件中，本节将学习如何读取被保存的参数数据。参数读取命令rosparam
load使用格式如下所示。

    rosparam load [file_name]

在使用该命令前先将params.yaml中的三个背景颜色的值都设置为0，并将其保存，其结果如图1-74所示。




修改完成后在终端输入如下命令。

    rosparam load params.yaml
    rosservice call /clear




得到结果如图1-75所示，当三种背景颜色都设置为0时，发现仿真器上的背景颜色变成了黑色。

**（7）rosparam delete命令**

当发现系统中有些多余的参数同样也被保存时，需要用rosparam
delete命令将多余的参数进行删除，其使用格式如下所示。

    rosparam delete [parameter_name]

在执行该命令前将小乌龟的背景颜色参数都设置为100，之后将用该命令删除/turtlesim/background_b后再刷新小乌龟的背景颜色，在终端输入命令如下所示。

    rosparam load params.yaml
    rosparam delete /turtlesim/background_b
    rosservice call /clear
    rosparam list

其结果如图1-76所示。




如图我们可以得知小乌龟的背景颜色发生了新的变化，并且使用rosparam
list命令查询参数列表，发现/turtlesim/background_b参数已经被我们成功删除了。

### 1.4.2通过编程实现参数的静态调节

**（1）相关功能包的创建**

在终端输入如下命令，以创建新的功能包。

    cd ~/catkin_ws/src
    catkin_create_pkg parameter roscpp rospy std_srvs dynamic_reconfigure

其在parameter文件夹里面生成的文件如图1-77所示。




在parameter文件夹下右击选择新建文件夹，新建一个名为scripts的文件夹，其用于存放用Python语言编写的代码，而src文件则用来存放用C++语言编写的代码，方便以后更好管理系统文件。其过程如图1-78所示。




在其中的src文件夹和scripts文件夹分别放入用于静态调节参数的代码文件。下面将分别从C++与Python两种语言来介绍如何用编程方式来实现参数的静态调整。

**（2）C++实现参数静态调整**

param_config节点的代码实现param_config.cpp如下所示。

    #include <string>
    #include <ros/ros.h>

    int main(int argc, char **argv)
    {
           int red, green, blue;

         // ROS节点初始化
         ros::init(argc, argv, "param_config");

         // 创建节点句柄
         ros::NodeHandle nh;

         // 读取背景颜色参数
           bool ifget1 = ros::param::get("/turtlesim/background_r", red);
           bool ifget2 = nh.getParam("/turtlesim/background_g", green);
           bool ifget3 = nh.param("/turtlesim/background_b", blue, 100);

         if(ifget1&&ifget2&&ifget3)
             ROS_INFO("Get Backgroud Color[%d, %d, %d]", red, green, blue);
         else
             ROS_WARN("Didn't retrieve all param successfully");
           // 设置背景颜色参数
             ros::param::set("/turtlesim/background_r", 255);
             ros::param::set("/turtlesim/background_g", 255);
             nh.setParam("/turtlesim/background_b",255);

             ROS_INFO("Set Backgroud Color[255, 255, 255]");

         // 读取背景颜色参数
         if(ros::param::get("/turtlesim/background_r", red))
             ROS_INFO("background_r = %d", red);
         else
             ROS_WARN("Didn't get param successfully");
         if(ros::param::get("/turtlesim/background_r", green))
             ROS_INFO("background_g = %d", green);
         else
             ROS_WARN("Didn't get param successfully");
         if(ros::param::get("/turtlesim/background_r", blue))
             ROS_INFO("background_b = %d", blue);
         else
             ROS_WARN("Didn't get param successfully");
          // 删除背景颜色参数
          bool ifdeleted1 = nh.deleteParam("/turtlesim/background_r");
          bool ifdeleted2 = ros::param::del("/turtlesim/background_b");
          if(ifdeleted1)
                  ROS_INFO("/turtlesim/background_r deleted");
            else
                  ROS_INFO("/turtlesim/background_r not deleted");
          if(ifdeleted2)
                  ROS_INFO("/turtlesim/background_b deleted");
            else
                  ROS_INFO("/turtlesim/background_b not deleted");
          // 查看背景颜色参数
          bool ifparam1 = nh.hasParam("/turtlesim/background_r");
          bool ifparam2 = ros::param::has("/turtlesim/background_b");
          if(ifparam1) 
                  ROS_INFO("background_r exists");
            else
                  ROS_INFO("background_r doesn't exist");
          if(ifparam2) 
                  ROS_INFO("background_b exists");
            else
                  ROS_INFO("background_b doesn't exist");
         
            sleep(1);
          return 0;
     }

下面将其进行拆分，分析其实现过程

    #include <string>
    #include <ros/ros.h>

该部分代码用于包含程序所必须要的头文件string用于字符串的操作，ros.h则用于与ros相关的操作，比如本节对于param的操作。

         int red, green, blue;
         // ROS节点初始化
         ros::init(argc, argv, "param_config");
         // 创建节点句柄
         ros::NodeHandle nh;

首先声明三个int型变量，用于存放参数里面的具体值，其次初始化节点，实质上是向节点管理器注册一个名为param_config的节点，最后创造了一个名为nh的句柄。

         bool ifget1 = ros::param::get("/turtlesim/background_r", red);
           bool ifget2 = nh.getParam("/turtlesim/background_g", green);
           bool ifget3 = nh.param("/turtlesim/background_b", blue, 100);

         if(ifget1&&ifget2&&ifget3)
             ROS_INFO("Get Backgroud Color[%d, %d, %d]", red, green, blue);
         else
             ROS_WARN("Didn't retrieve all param successfully");

ROS中提供了以下两种API来访问参数的值，分别为ros::param和ros::NodeHandle，所以我们有如下三种方式来获取参数的值。

    bool ifget1 = ros::param::get("/turtlesim/background_r", red）

该语句用ros::param访问参数，将访问的获得的/turtlesim/background_r参数值写入到red这个整型变量中，当该函数执行成功后会返回1，并将其赋值给布尔型变量ifget1来判断是否成功读取到参数值。

    bool ifget2 = nh.getParam("/turtlesim/background_g", green)

该语句用ros::NodeHandle来访问系统的参数，该语句作用与上一语句相同，通过句柄nh获得参数值并赋值给变量，并判断是否执行成功。

    bool ifget3 = nh.param("/turtlesim/background_b", blue, 100)

该语句同样使用ros::NodeHandle来访问系统的参数，但与上一个语句不同的是，如果该语句没有找到对应的参数，会将一个提前确定的默认值写入变量，本语句的默认值为100。所以如果系统没有找到对应参数时，会将100赋值给blue。

    if(ifget1&&ifget2&&ifget3)
             ROS_INFO("Get Backgroud Color[%d, %d, %d]", red, green, blue);
         else
             ROS_WARN("Didn't retrieve all param successfully");

该语句用于判断三个参数是否都访问成功，只有当三个布尔型变量都为1时if语句才会成立，系统会在终端输出访问到的参数值，如果存在一个以上布尔型变量为0时，系统会在终端发出警告。

         ros::param::set("/turtlesim/background_r", 255);
         ros::param::set("/turtlesim/background_g", 255);
         nh.setParam("/turtlesim/background_b",255);
         ROS_INFO("Set Backgroud Color[255, 255, 255]");

该部分语句用主要用于参数值的设置，并输出设置的参数值。

         ros::param::set("/turtlesim/background_r", 255);
         nh.setParam("/turtlesim/background_b",255);

该语句用ros::param访问参数，其作用为将/turtlesim/background_r参数中的值设置为255。

         nh.setParam("/turtlesim/background_b",255);

该语句用ros::NodeHandle来访问系统的参数，作用和上一语句一致，区别在于设置的参数对象不同。

         if(ros::param::get("/turtlesim/background_r", red))
             ROS_INFO("background_r = %d", red);
         else
             ROS_WARN("Didn't get param successfully");
         if(ros::param::get("/turtlesim/background_r", green))
             ROS_INFO("background_g = %d", green);
         else
             ROS_WARN("Didn't get param successfully");
         if(ros::param::get("/turtlesim/background_r", blue))
             ROS_INFO("background_b = %d", blue);
         else
             ROS_WARN("Didn't get param successfully");

该部分语句用于读取我们之前设置过的参数的值，并将其输出至终端。

         if(ros::param::get("/turtlesim/background_r", red))
             ROS_INFO("background_r = %d", red);
         else
             ROS_WARN("Didn't get param successfully");

当系统成功读取到参数的值之后，将读取到的数据赋值给red变量，并在if函数中反馈数值1，使得系统执行if中的内容，输出red中的值，而如果读取失败，则系统会执行else中的内容，终端中会输出一个获取失败的警告。

          bool ifdeleted1 = nh.deleteParam("/turtlesim/background_r");
          bool ifdeleted2 = ros::param::del("/turtlesim/background_b");
          if(ifdeleted1)
                  ROS_INFO("/turtlesim/background_r deleted");
            else
                  ROS_INFO("/turtlesim/background_r not deleted");
          if(ifdeleted2)
                  ROS_INFO("/turtlesim/background_b deleted");
            else
                  ROS_INFO("/turtlesim/background_b not deleted");

该部分代码用于删除系统中的参数，并判断是否删除成功。

          bool ifdeleted1 = nh.deleteParam("/turtlesim/background_r");

该语句用ros::NodeHandle访问参数，来删除指定的参数。当该函数执行成功时会反馈数值1，并将其赋值给布尔型变量ifdeleted1，用于之后判断是否删除成功。

          bool ifdeleted2 = ros::param::del("/turtlesim/background_b");

该语句用ros::param访问参数，其作用和上一语句相同，区别在于指定参数对象不同。

          if(ifdeleted1)
                  ROS_INFO("/turtlesim/background_r deleted");
          else
                  ROS_INFO("/turtlesim/background_r not deleted");

该语句用于判断删除语句是否执行成功，当布尔值为1，即删除语句执行成功时，系统会执行if语句内的内容，即在终端输出参数删除成功，反之则会在终端输出参数删除失败。

          bool ifparam1 = nh.hasParam("/turtlesim/background_r");
          bool ifparam2 = ros::param::has("/turtlesim/background_b");
          if(ifparam1) 
                  ROS_INFO("background_r exists");
          else
                  ROS_INFO("background_r doesn't exist");
          if(ifparam2) 
                  ROS_INFO("background_b exists");
          else
                  ROS_INFO("background_b doesn't exist");

该部分代码用于判断指定参数是否存在并在终端中输出结果。

          bool ifparam1 = nh.hasParam("/turtlesim/background_r");

该语句用ros::NodeHandle访问参数，来核查指定的参数，当该语句执行成功后会反馈数值1并将其赋值到变量ifparam1，用于之后在终端中输出结果。

    bool ifparam2 = ros::param::has("/turtlesim/background_b");

该语句用ros::param访问参数，其作用和上一语句相同，区别在于指定参数对象不同。

在编译工作空间之前我们需要配置CMakeLists.txt中的编译规则，需要设置需要编译的代码及其生成的可执行文件的名字和设置连接库，将如下语句增加到如图1-79所示的位置中。

    add_executable(param_config src/param_config.cpp)
    target_link_libraries(param_config ${catkin_LIBRARIES})




下面在终端中输入以下语句完成编译。

    cd ~/catkin_ws
    catkin_make
    source devel/setup.bash
    roscore
    rosrun turtlesim turtlesim_node
    rosrun parameter param_config

其中source如果之前在.bashrc文件中配置过了则不需要输入，其执行结果如图1-80所示




该结果的输出显示对于背景颜色参数进行的操作都执行成功了，因为C++中没有类似rosparam
list这种指令的语句，所以只能在终端中输入如下命令来显示参数列表和刷新小乌龟仿真器的背景颜色。

    rosparam list
    rosservice call /clear

其结果如图1-81所示




该结果显示目前存在的参数只有/turtlesim/background_g，说明其他的参数已经本我们成功删除了，而此时刷新过后的背景颜色为绿色，这也与当前存在的参数结果相符。

**（3）Python实现参数静态调整**

用Python实现这一目的的方式和C++类似，但是语句规则存在区别。其代码实现param_config.py如下所示。

    #!/usr/bin/env python
    # coding:utf-8

    import sys
    import rospy

    def param_config():
        # ROS节点初始化
        rospy.init_node('param_config', anonymous=True)

        # 读取背景颜色参数
        red   = rospy.get_param('/turtlesim/background_r')
        green = rospy.get_param('/turtlesim/background_g')
        blue  = rospy.get_param('/turtlesim/background_b')

        rospy.loginfo("Get Backgroud Color[%d, %d, %d]", red, green, blue)

        # 设置背景颜色参数
        rospy.set_param("/turtlesim/background_r", 255);
        rospy.set_param("/turtlesim/background_g", 255);
        rospy.set_param("/turtlesim/background_b", 0);

        rospy.loginfo("Set Backgroud Color[255, 255, 0]");

        # 读取背景颜色参数
        red   = rospy.get_param('/turtlesim/background_r')
        green = rospy.get_param('/turtlesim/background_g')
        blue  = rospy.get_param('/turtlesim/background_b')

        rospy.loginfo("Get Backgroud Color[%d, %d, %d]", red, green, blue)
       # 删除背景颜色参数
        rospy.delete_param('/turtlesim/background_b')
         
        ifparam1 = rospy.has_param('/turtlesim/background_b')
        if(ifparam1):
            rospy.loginfo('/turtlesim/background_b exists')
        else:
            rospy.loginfo('/turtlesim/background_b does not exist')
        # 参数列表
        params = rospy.get_param_names()
        rospy.loginfo('param list: %s', params)
        
    if __name__ == "__main__":
        param_config()

下面我们将其进行拆分，分析其实现过程。

    #!/usr/bin/env python
    # coding:utf-8

该部分代为Python的头文件配置。

    #!/usr/bin/env python

该代码作用是在运行python脚本的时候告诉操作系统我们要用python解释器去运行py脚本。

    # coding:utf-8

该部分代码是告诉Python解释器:此源程序是utf-8编码的，也即告诉python解释器要按照utf-8编码的方式来读取程序。

      rospy.init_node('param_config', anonymous=True)

该部分初始化了一个名为param_config的节点，而anonymous=True作用则是当之后定义了一个同名的节点时，按照序号进行排列。

        red   = rospy.get_param('/turtlesim/background_r')
        green = rospy.get_param('/turtlesim/background_g')
        blue  = rospy.get_param('/turtlesim/background_b')

        rospy.loginfo("Get Backgroud Color[%d, %d, %d]", red, green, blue)

该部分语句用于获取参数值。

        red   = rospy.get_param('/turtlesim/background_r')

该语句将/turtlesim/background_r的参数值读取后并赋值给red变量。

        rospy.loginfo("Get Backgroud Color[%d, %d, %d]", red, green, blue)

该语句用于在终端输出读取到的参数值。

        rospy.set_param("/turtlesim/background_r", 255);
        rospy.set_param("/turtlesim/background_g", 255);
        rospy.set_param("/turtlesim/background_b", 0);

        rospy.loginfo("Set Backgroud Color[255, 255, 0]");

该部分语句用于对参数进行赋值。

        rospy.set_param("/turtlesim/background_r", 255);

该语句将/turtlesim/background_r参数里面的值赋值为为255。

        rospy.delete_param('/turtlesim/background_b')
         
        ifparam1 = rospy.has_param('/turtlesim/background_b')
        if(ifparam1):
            rospy.loginfo('/turtlesim/background_b exists')
        else:
            rospy.loginfo('/turtlesim/background_b does not exist')

该部分语句实用于删除参数并在终端显示删除结果。

        rospy.delete_param('/turtlesim/background_b')

该部分代码用于删除/turtlesim/background_b参数。

        ifparam1 = rospy.has_param('/turtlesim/background_b')

该代码用于判断/turtlesim/background_b参数是否存在，如果存在会返回数值1，反之会反馈数值0。

        if(ifparam1):
            rospy.loginfo('/turtlesim/background_b exists')
        else:
            rospy.loginfo('/turtlesim/background_b does not exist')

该代码用于向终端输出参数的存在状况。

        params = rospy.get_param_names()
        rospy.loginfo('param list: %s', params)

该部分代码用于显示参数列表

        params = rospy.get_param_names()

该语句用于获取现存的所有参数名并将其以字符串的形式传输给params

        rospy.loginfo('param list: %s', params)

该部分代码用于在终端输出获得到的所有参数名

Python代码相较于C++的好处是不需要在CMakeLists中修改其编译规则，只需要在属性中允许其作为程序执行文件即可。我们需要，右击并打开添加python文件的属性，将"允许文件作为程序执行(E)"这个选项勾选，其界面如图1-82所示




与C++编程一样需要对其进行编译和执行，在终端输如以下命令

    cd ~/catkin_ws
    catkin_make
    source devel/setup.bash
    roscore
    rosrun turtlesim turtlesim_node
    rosrun parameter param_config.py




其执行结果如图1-83所示，从列出的参数列表中得知/turtlesim/background_b已经被删除了，此时在终端输入如下命令刷新小乌龟仿真器的背景颜色。

       rosservice call /clear

其结果如图1-84所示




### 1.4.3实现参数的动态调节

在进行系统调试时需要经常修改程序中的参数值，这时无论是命令修改机制，还是编写固定修改参数的可执行文件，都无法满足要求。而ROS为我们提供了动态参数设置机制。

**（1）创建cfg文件**

在创建的parameter的功能包中创建一个cfg文件夹用于存放.cfg文件，并在其中创建一个配置文件Tutorials.cfg文件，代码结构图如下所示。

    paramerer/
      package.xml 
      CMakeLists.txt
      cfg/
        Tutorials.cfg
      include/
        parameter
      src/
        dynamic_parameter.cpp

其中Tutorials.cfg的代码如下所示，该配置文件用Python实现。

    #!/usr/bin/env python
    PACKAGE = "parameter"

    from dynamic_reconfigure.parameter_generator_catkin import *

    gen = ParameterGenerator()

    gen.add("int_param",    int_t,    0, "An Integer parameter show", 50,  0, 100)
    gen.add("double_param", double_t, 0, "A double parameter show",    5, 0,   10)
    gen.add("str_param",    str_t,    0, "A string parameter show",  "Hello World!")
    gen.add("bool_param",   bool_t,   0, "A Boolean parameter show",  False)

    size_enum = gen.enum([ gen.const("Stop",      int_t, 0, "A stop speed"),
                           gen.const("Low_speed",     int_t, 1, "A low drive speed"),
                           gen.const("Medium_speed",      int_t, 2, "A medium drive speed"),
                           gen.const("Fast_speed", int_t, 3, "An fast drive speed")],
                         "An enum to set size")

    gen.add("size", int_t, 0, "A size parameter which is edited via an enum", 1, 0, 3, edit_method=size_enum)

    exit(gen.generate(PACKAGE, "dynamic_parameter", "Tutorials"))

下面我们对其进行分解并进行详细的解释。

    #!/usr/bin/env python
    PACKAGE = "parameter"

    from dynamic_reconfigure.parameter_generator_catkin import *

该部分代码中PACKAGE后面为该功能包名，而导入的则是dynamic_reconfigure功能包中提供的parameter
generator（参数生成器）。

    gen = ParameterGenerator()

该代码用于创建一个名为gen的参数生成器，用于下面定义需要动态配置的参数。

    gen.add("int_param",    int_t,    0, "An Integer parameter show", 50,  0, 100)
    gen.add("double_param", double_t, 0, "A double parameter show",    5, 0,   10)
    gen.add("str_param",    str_t,    0, "A string parameter show",  "Hello World!")
    gen.add("bool_param",   bool_t,   0, "A Boolean parameter show",  False)

这部分代码用于生成四类不同类型的参数，其使用格式如下所示。

    gen.add（name， type， level， description, default, min, max）

上面的格式中name为定义的参数名，注意不能和C++中的定义好的变量类型重名。type为定义的参数的类型，可以为int_t(整型)、double_t(双精度浮点型)、str_t（字符串型）或者是bool_t（布尔型）。其中level为需要传入参数的动态配置回调函数中的掩码，在回调函数中将所有参数的掩码进行修改，来标识传入的参数已经进行了调整。description为用于描述参数信息的字符串。default为设置的参数的默认值。min与max分别为设置的参数的最大值和最小值，但因字符串和布尔型类型的特性，所以对这两类数据不需要进行最值的设置。

    size_enum = gen.enum([ gen.const("Stop",      int_t, 0, "A stop speed"),
                           gen.const("Low_speed",     int_t, 1, "A low drive speed"),
                           gen.const("Medium_speed",      int_t, 2, "A medium drive speed"),
                           gen.const("Fast_speed", int_t, 3, "An fast drive speed")],
                         "An enum to set size")

    gen.add("size", int_t, 0, "A size parameter which is edited via an enum", 1, 0, 3, edit_method=size_enum)

上面的代码用于生成一个枚举类型的参数，该参数名为size，类型为int_t型。通过gen.eum()来定义一个枚举并将其传递给常量列表，而每一个枚举值的名称、类型、取值及描述则由gen.const（）来初始化。size参量的值由定义的枚举来赋值。

    exit(gen.generate(PACKAGE, "dynamic_parameter", "Tutorials"))

该指令用于生成必要文件并退出，其中第二个参数表示动态参数运行的节点名及自己服务端程序中初始化的节点名。第三个参数是生成文件使用的前缀，需要和配置文件文件名相同。

当配置文件完成之后，我们需要在终端输入如下命令为配置文件增加可执行权限。

    chomd a+x cfg/Tutorials.cfg

该文件因需要生成代码文件，所欲需要在CMakeLists.txt文件中增加如下编译规则。

    generate_dynamic_reconfigure_options(cfg/Tutorials.cfg）
    add_dependencies(dynamic_parameter ${PROJECT_NAME}_gencfg)

位置分别如






**(2)动态参数服务端的实现**

在src文件下创建一个用于实现服务端的dynamic_parameter.cpp文件，代码如下所示。

    #include "ros/ros.h"
    // 定义的动态参数
    #include <dynamic_reconfigure/server.h>
    #include <parameter/TutorialsConfig.h>

    void Callback(parameter::TutorialsConfig &config, uint32_t level)
    {
        ROS_INFO("Reconfigure Request: %d %f %s %s %d",
        config.int_param,
        config.double_param,
        config.str_param.c_str(),
        config.bool_param?"True":"False",
        config.size);

    }

    int main(int argc, char **argv)
    {
        ros::init(argc, argv, "dynamic_parameter");
        dynamic_reconfigure::Server<parameter::TutorialsConfig> server;
        dynamic_reconfigure::Server<parameter::TutorialsConfig>::CallbackType f;
        f = boost::bind(&Callback, _1, _2);
        server.setCallback(f);
      ROS_INFO("Spinning node");
        ros::spin();
        return 0;
    }

下面我们对其进行分解并进行详细的解释。

    #include "ros/ros.h"
    #include <dynamic_reconfigure/server.h>
    #include <parameter/TutorialsConfig.h>

该部分代码用于头文件的生成，其中TutorialsConfig.h为之前.cfg文件生成的，server.h为调用的dynamic_reconfigure功能包生成的。

      ros::init(argc, argv, "dynamic_parameter");
        dynamic_reconfigure::Server<parameter::TutorialsConfig> server;

该部分代码用处初始化一个名为dynamic_parameter的节点，并创建了一个参数动态配置的服务端，参数配置的类型为之前配置文件中定义的类型。该服务端会实时监听客户端的参数配置请求。

        dynamic_reconfigure::Server<parameter::TutorialsConfig>::CallbackType f;
        f = boost::bind(&Callback, _1, _2);
        server.setCallback(f);

该部分代码定义了一个回调函数
f，将回调函数与服务端相绑定，当客户端请求修改参数时，服务端将自动跳到回调函数中并进行处理。

    void Callback(parameter::TutorialsConfig &config, uint32_t level)
    {
        ROS_INFO("Reconfigure Request: %d %f %s %s %d",
        config.int_param,
        config.double_param,
        config.str_param.c_str(),
        config.bool_param?"True":"False",
        config.size);
    }

上述为该回调函数的内容，回调函数输入的参数为两个，其中parameter::TutorialsConfig
&config为新的参数配置，uint32_t
level为修改参数的掩码。在回调函数中将新配置的参数在终端输出。

在CMakeLists.txt中加入以下编译规则

    add_executable(dynamic_parameter src/dynamic_parameter.cpp)
    target_link_libraries(dynamic_parameter ${catkin_LIBRARIES})
    add_dependencies(dynamic_parameter ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})

CMakeLists.txt最终结果如图1-87所示




**（3）实现结果**

编译成功之后在终端输入如下命令

    roscore
    rosrun parameter dynamic_parameter
    rosrun rqt_reconfigure rqt_reconfigure




其最终结果如图1-88所示，在可视化界面中，可以通过输入字符串，拖动，下拉选择，点击等各种方式来修改各类型的参数，其调整方式与配置文件中参数类型的设置有关，比如设置了最值，就会出现拖动条，设置了字符串类型就可以输入字母，设置了枚举类就可以下拉选择，设置了布尔型就可以点击选择，并且每次修改都会在服务端终端中看到调整后的参数结果。

# 1.5 visual studio code环境搭建与美化

## 1.5.1 环境搭建

从网站下载好的visual studio code
如下图1-88所示，如果对于英文不是很熟悉，推荐使用中文界面进行代码的编写，所以我们第一步需要把visual
studio code强大的插件，将软件界面设置成中文界面。




左侧工具栏，如下图1-90和图1-91所示，第一个是资源管理器，第二个是git工具，第三个是调试，第四个是拓展。




打开拓展菜单，搜索"Chinese"，点击"Install"，设置vscode语言为中文。




等待软件下载安装完成，只需要更新并重启visual studio
code，软件便可以切换成为中文界面。

visual studio code
作为一个现代编辑器，不可以直接运行文件，需要有一个工作文件夹，在使用时需要先选择"文件→选择文件夹"来指定工作文件夹，或者直接把文件夹拖动到vscode图标上。如图1-92所示




此外，我们还可以使用快捷键来大大加快开发速度，下图为官方提供的快捷键清单。如图1-93所示




visual studio code有强大的C++，python
自动补全功能，作为初学者而言，很多时候难以记得那么多函数库，而visual
studio code提供了代码补全的功能，使我们的代码编写事半功倍。

为了提升编程的效率，我们需要安装C++插件，在应用商店里面搜索C++，下载如下两个插件：安装插件步骤如图1-94所示。




当我们创建好一个项目的时候，需要对插件进行配置，来启动自动补全的功能。按F1后输入C++，电机配置JSON来创建一个json文件来配置C++的自动补全功能，我们可以发现，在工程文件的根目录下面，多了一个.vscode的文件夹，以"."开头的文件，在Linux系统下属于是隐藏文件，".vscode"的作用是配置visual
studio code各项参数，如图1-95所示。




c_cpp_properities.json文件是用来配置自动补全插件的，如果写程序的时候出现可以编译成功但是自动补全一直报错的情况，应该优先考虑是不是由于c_cpp_properities.json文件没有正确配置造成的。如图1-96所示。




本文使用的编译器是g++而非默认值，需要在json文件里面做出改变。

    {
        "configurations": [
            {
                "name": "Linux",
                "includePath": [
                    "${workspaceFolder}/**"
                ],
                "defines": [],
                "compilerPath": "/usr/bin/g++",
                "cStandard": "c11",
                "cppStandard": "c++11",
                "intelliSenseMode": "linux-gcc-x64"
            }
        ],
        "version": 4
    }

改变内容有"compilerPath"，描述的是正在启用的编译器完整的路径，以启用更准确的自动补全功能。"cStandard"用来描述自动补全的C语言标准的版本，"cppStandard"用来描述自动补全C++语言标准版本，"intelliSenseMode"表示的是要使用的，映射到MSVC、gcc或者是Clang平台和结构变体的IntelliSense模式。

如果我们添加了更多的头文件，我们还需要继续把包含头文件的路径添加进入C、C++插件的路径里面。

除此之外，如果我们对python编写也有需求的话，推荐下载python的插件，下载步骤如下所示，在拓展中搜索python，然后在相应的插件下面单机"Install"，当程序加载好以后，便可以自动缩进了。如图1-97所示



图1-97安装python插件

## 1.5.2 visual studio code 美化

在写程序的时候，为了提高代码的可读性，我们会在程序里面增加换行，缩进等规范。Visual
Studio Code
提供了规范化代码的功能，使我们在写代码的时候可以一键格式化代码。

每次写完C程序时候，可以使用快捷键"control+shift+I"来规范化C语言程序。如果想让程序在保存时候自动更新格式，可以使用快捷键"control +
，"进入设置界面，搜索"format on
save"并勾选，这样在配置过语言格式化规范以后，当我们保存文件的时候，代码可以自动执行格式化的功能。这样，在写完代码以后，只需要按"control+s"或者执行"编辑→保存"变可以将代码格式调整规范。如图1-98所示。




同时我们可以加入一些第三方的插件来增强Vscode的管理与配置：

1.  Material Icon Theme插件：美化资源管理器下单图标。

2.  Bracket Pair
    Colorizer2插件：直接安装即可使用，可以实现括号内多色，放置错误匹配。

3.  Svg Preview插件：可以用来打开svg文件，安装即可使用。

4.  indent-rainbow插件：多彩缩减，安装即可使用，如果错了可以标红。

5.  Clang-Format插件：C++格式化插件，这样代码可以以C++11的标准严格要求代码格式。

6.  Code Spell Checker插件：检查代码拼写的插件。

7.  Docker插件：可以在Vscode中远程访问Docker容器。

8.  Git Graph插件：可以绘制Git的branch树，方便进行任务管理。

9.  Git History插件：可以查找所有的Git提交任务。

10. Markdownlint插件：Vscode撰写Markdown文档的插件。

11. XML Tool插件：XML文件的管理插件，经常被用于Package.xml文件中。

12. Remote
    SSH插件：远程连接工具，可以跨电脑撰写代码，非常适用于机器人远程开发。

一些常用的插件如图1-99所示




# 1.6 Docker-ROS安装

### 1.6.1 了解Docker 

**（1）Docker的概念**

Docker是一个开源的应用容器引擎，是一种轻量级的虚拟化技术。开发者可以运用该技术将自己开发好的工程或项目以及依赖包打包至一个可以移植的容器中，该容器可以安装至任意运行系统为Linux或Windows等的服务器上。相较于传统VM虚拟机需要安装操作系统才能执行应用程序，占用系统资源过多的情况，Docker容器作为一种轻量级的虚拟化方式具有消耗系统资源少、运行数量多、可以通过Dockerfile配置文件实现自动化创建和灵活部署，提高工作效率等特点。因此该技术被越来越多的企业所采用。\
Docker容器的作用于虚拟机一样，都是为了实现"环境隔离"。但虚拟机的隔离是从操作系统层级开始隔离，而Docker容器则是采用进程层级的系统隔离，因此大大减少了系统资源的浪费和消耗，极大提升了开发效率。其可以将各种应用及其依赖都封装到Docker镜像文件中，并可以在任何物理设备（主要是linux系统和windows系统）中安装和运行，使其摆脱底层设备的限制，可以在物理设备之间灵活迁移，加大其可兼容性，减少后期运行维护的工作量。\
Docker的三大组成要素：\
镜像
：Docker镜像是一个特殊的文件系统，其不仅提供了一个容器在运行时所必须的各种库、资源、配置等文件，还包含了该容器在运行时所需要的配置参数。Docker镜像被用于创造Docker容器，一个镜像可以安装多个容器。镜像可以简化理解为实例的创建模板。\
容器：Docker容器是镜像创建的运行实例，Docker系统用容器来运行应用。每一个容器之间都是相互隔离的平台。\
仓库：仓库用于存放镜像文件。当操作者创建完镜像之后，可将镜像上传至公共区和私有区，当用户需要在另一个服务器使用该镜像时，只需下载即可。\
**（2） Docker的运行流程：**\
Docker使用的是客户端/服务器 (C/S) 架构模式。Docker
daemon（守护进程）作为服务端接收Docker客户端的请求，其主要负责Docker容器的创建、运行和分配，监测Docker
API的请求和管理Docker对象，比如镜像、容器、网络和数据卷。守护进程一般运行在Docker主机后台，操作者通过客户端与守护进程进行信息交互。其运行流程如图1-100所示。




从图得知操作者在客户端向守护者进程发送请求（Docker build、Docker
pull和Docker
run等指令）守护者进程和服务器根据相关指令完成后续操作。Docker
build指令中守护者进程会根据Docker文件构建一个镜像存放于本地Docker主机。Docker
pull指令中守护者进程会从云端仓库中拉取镜像至本地Docker主机或将本地镜像推送至云端仓库。Docker
run指令中守护者进程会将镜像安装至容器并启动容器。Docker主机则用于执行守护者进程和容器。

### 1.6.2 Docker的安装

首先我们在终端中输入如下命令打开source.list文件。

    sudo gedit /etc/apt/sources.list

在其中添加下列内容，用于添加清华镜像源，本镜像源适用于ubuntu18.04版本。

    # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释
    deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse
    # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse
    deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse
    # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse
    deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse
    # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse
    deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse
    # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse

    # 预发布软件源，不建议启用
    # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse
    # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse

在终端中输入如下命令更新apt。

    sudo apt-get update

在安装新版本docker前我们需要先对系统中的旧版本进行卸载（如果存在的话），在终端输入如下命令。

    sudo apt-get remove docker docker-engine [docker.io](http://docker.io/) containerd runc

输入如下命令来安装软件包以允许apt通过https使用存储库。

    sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common

在终端输入如下命令来添加Docker的官方GPG公钥。

    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

在终端中输入如下命令来添加Docker的远程仓库。

    echo \
      "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \
      $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
    sudo apt-get update

在终端中输入如下命令来安装Docker Engine、containerd和Docker Compose。

    sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin

为了提升下载速度，我们需要将docker的镜像源更换为国内的镜像源，在终端中输入如下命令打开/etc/docker/daemon.json文件（如果不存在，系统会自动创建该文件）。

    sudo gedit /etc/docker/daemon.json

在其中添加如下代码。

    {
        "registry-mirrors": 
        [
         "https://mirror.ccs.tencentyun.com",
         "https://docker.mirrors.ustc.edu.cn"
        ]
    }

在终端输入如下代码重启docker。

    sudo systemctl restart docker

输入如下命令测试docker是否安装成功。

    sudo docker run hello-world

如果安装成功，其反馈结果如图1-101所示。




下面实现令普通用户也可以使用docker命令，先在终端中输入如下命令来添加"docker
group"，如果已经存在终端会反馈已经存在的消息。

    sudo groupadd docker

在终端中输入如下命令来将用户添加到刚添加的group中。

    sudo gpasswd -a [admin_name] docker

其中\[admin_name\]为使用者的用户名，具体输入内容由每个人的用户名来决定。

在终端中输入如下命令来修改"docker.sock"文件的权限为所有人都可读写。

    sudo chmod a+rw /var/run/docker.sock

在终端中输入如下命令重启docker系统。

    sudo service docker restart

在终端中输入如下命令将当前会话切换到创建的新 group。

    newgrp - docker

在终端输入如下命令显示安装的docker的相关细节。

    docker version

其结果如图1-102所示。




### 1.6.3在Docker内安装ROS

在终输入如下命令，该命令用与将ROS官方的镜像拉下来，即下载。

    docker pull osrf/ros:kinetic-desktop-full

其安装结果如图1-103所示。




下载完成后在终端输入如下命令来查看获得的镜像文件。

    docker images

其结果如图1-104所示，我们获得的是osrf/ros的镜像。




在终端输入如下命令根据获得的镜像创建容器，并确认是否创建成功。

    docker run -it osrf/ros:kinetic-desktop-full bash
    roscore

运行结果如图1-105所示。



图1-105容器中开启节点管理器

### 1.6.4在Docker安装vncserver

在终端中输入如下命令，该命令用于开放权限，允许所有用户，当然包括docker,访问X11的显示接口。

    xhost +

图1-106为该指令运行成功的结果，用户可自行跳转（5）




如果显示 xhost: unable to open display
则说明用户没有安装vncserver。在新的终端中输入如下命令安装vncserver。

    sudo apt-get install tigervnc-standalone-server tigervnc-viewer

安装完成后输入如下命令进入root启动vncserver。

    su root
    vncserver

其结果如图1-107所示。




### 1.6.5测试docker中ROS及其GUI界面

在终端输入如下命令来新建一个带GUI环境变量的容器。

    docker run -it \
        --env="DISPLAY" \
        --env="QT_X11_NO_MITSHM=1" \
        --volume="/tmp/.X11-unix:/tmp/.X11-unix:rw" \
        osrf/ros:kinetic-desktop-full \
        /bin/bash

其中--env="DISPLAY"可以开启显示GUI界面，--env="QT_X11_NO_MITSHM=1"
是采用X11的端口1进行显示，
--volume="/tmp/.X11-unix:/tmp/.X11-unix:rw"是映射显示服务节点目录，osrf/ros:kinetic-desktop-full表示容器从镜像osrf/ros:kinetic-desktop-full创建，/bin/bash系统运行命令bash。

创建之后系统自动进入docker，在终端输入如下命令。

    source /opt/ros/kinetic/setup.bash
    roscore

其中source命令运行的setup.bash让可以一些ROS开头的命令可以使用，同时还能够创建一些ROS开头的环境变量。

在新的终端输入如下命令以查看目前所有的容器的名字。

    docker ps –all

创建的容器如图1-108所示，我们创建的ros容器名称为recursing_lamarr。




通过以下命令进入我们刚创建的容器中。

    docker exec -it recursing_lamarr /bin/bash

其中recursing_lamarr为对应的容器名，进入容器后运行以下命令以运行小乌龟仿真器。

    source /opt/ros/kinetic/setup.bash
    rosrun turtlesim turtlesim_node

打开的界面如图1-109所示




在第三个终端中同样输入如下命令打开键盘控制节点。

    docker exec -it recursing_lamarr /bin/bash
    source /opt/ros/kinetic/setup.bash
    rosrun turtlesim turtle_teleop_key

打开的界面如图1-110所示




同样在新的终端中输入如下命令打开rviz。

    docker exec -it recursing_lamarr /bin/bash
    source /opt/ros/kinetic/setup.bash
    rviz

其结果如图1-111所示，虽然出现了一些报错错误导致某些功能包无法打开，但是rviz可视化界面可以正常打开。




同样在新的终端中输入如下命令打开gazebo。

    docker exec -it recursing_lamarr /bin/bash
    source /opt/ros/kinetic/setup.bash
    gazebo

其结果如图1-112所示与rviz类似，可以正常打开可视化界面，但这里报错的原因是参数模型没有导入进去。




# 1.7 ROS搭建VSC调试环境

### 1.7.1 安装插件

在VScode中输入ROS按装如1-113图所示的ROS插件Material Icon Theme




在VScode中输入Material Icon Theme并安装如下图1-114所示的插件。




### 1.7.2 在VScode中配置ROS环境

当其添加成功之后关闭VScode，在之前创建的catkin_ws的工作空间中打开新的终端并输入如下命令以打开Vscode。

    code

用命令重新打开VScode后，发现系统会自动识别该工作空间，并附带的生成了.vscode文件夹，里面存在两个json文件，其结果如图1-115所示。




其中c_cpp_properties.json用于配置编译器环境，将其修改成如图1-116所示，其中重要的是includePath，包含了所有用到的头文件的目录。




而setting.json文件则与Python的编译有关。

功能包的创建需要右键src文件夹，在弹出的选项中选择Create Catkin
Package，其结果如图1-117所示。




创建功能包的名字如图1-118所示




在该界面输入功能包的名字，新建一个名为test的功能包，其功能包依赖如图1-119所示。




在该界面输入功能包的依赖，在test功能包中添加roscpp rospy std_msgs依赖

其生成结果如图1-120所示。




在生成的test功能包中右键src文件，在弹出的选项中点击新建文件，建立一个test.cpp的文件，因为之前安装过Material
Icon Theme，所以该文件会自动变成C++的图标，其结果如图1-121所示。




点击上面任务菜单中的终端，在弹出的选项中选择新建终端，其结果如图1-122所示。




其生成的终端界面如图1-123所示。




该终端中输入的命令与在Liunx中自带终端里输入的命令相同。

### 1.7.3 在VScode中debug代码

在我们之前新创建的C++文件中添加如下代码。

    #include <iostream>

    void swap (int *px, int *py)
     {
       int temp=*px;
       *px=*py;
       *py=temp;
     }

    int main()
     {
       using namespace std;
       int a=1, b=2;
       cout<<"before swap:"<<endl;
       cout<<"a="<<a<<",b="<<b<<endl;
       swap(&a, &b);
       cout<<"after swap:"<<endl;
       cout<<"a="<<a<<",b="<<b<<endl;
     }

在CMakeLists文件中添加如下命令。

    add_executable(test src/test.cpp)
    target_link_libraries(test ${catkin_LIBRARIES})

将该部分代码编译完成后进行对应的debug。

点击左侧的运行与调试，其图标如图1-124所示。




点击该图标后在上方点击添加配置，其图标如图1-125所示。




依次选择C++（GDB/LLDB）、默认配置，如果是第一次debug，系统会自动生成launch.json，将其内部配置为如图1-126所示。




其中我们需要关注的只有program，该部分需要写入的是编译后运行程序的路径，其中\${workspaceFolder}为工作空间所在路径，我们只需要补全即可。

当这些预备工作进行结束之后我们正式开始debug代码，点击debug图标和需要debug的代码，并在对应语句中设置断点（在对应语句前单击），其结果如图1-127所示




我们点击左上角的debug图标并选择调试C++文件，其结果如图1-128所示。




点击完值后出现的程序debug界面如图1-129所示。




调试界面如图1-130所示。




下面我们将以之后讲述的publisher程序进行debug，其结果如图1-131所示。




其中左边用于观察变量的变化，其中单步执行会使得程序自动调到下一语句，变量也会随之变化，当语句跳到函数中时，系统也随之跟随到函数中的语句，我们可以用此来观察程序执行状况。如果要编译ros程序也是类似，只需要对.vscode文件夹里面的四个文件进行替换即可。

其中c_cpp_properties.json文件中的内容如下所示。

    {
        "configurations": [
            {
                "browse": {
                    "databaseFilename": "",
                    "limitSymbolsToIncludedHeaders": true
                },
                "includePath": [
                    "/opt/ros/melodic/include/**",
                    "/usr/include/**",
                    "${workspaceFolder}/src/catkin_ws/**"
                ],
                "name": "ROS",
                "compileCommands": "${workspaceFolder}/build/compile_commands.json"
            }
        ],
        "version": 4
    }

该文件主要用于配置编译器环境，其中：

①
"browse"主要用于解决define的问题，系统会自动搜索相应browse.path字段中所有的宏定义，让define操作能够正常使用，在本例中并没有添加指定路径，而是将其中的"limitSymbolsToIncludedHeaders"设置为true，这样系统会自动递归搜查\${workspaceFolder}路径中的所有源文件。

②
"includePath"主要用解决include的问题，系统会自动递归搜寻我们设置路径下的所有头文件。

③ "name"用于表示配置文件，一般都是内核的名字，如本例中的ROS。

④
"compileCommands"：该路径一般用于解决include和define的问题，系统会使用工作空间中compile_commands.json文件中的完整路径，并使用在此文件中包含的include和define。而不是"browse"与"includePath"中规定的路径和定义。因为我们之前已经对include和define进行规定，所以本部分用不到。

其中，setting.json文件中的内容如下所示。

    {
        "python.autoComplete.extraPaths": [
            "/opt/ros/melodic/lib/python2.7/dist-packages"
        ],
        "files.associations": {
            "cctype": "cpp",
            "clocale": "cpp",
            "cmath": "cpp",
            "csignal": "cpp",
            "chrono": "cpp",
            "complex": "cpp",
            "condition_variable": "cpp",
            "cstdint": "cpp",
            "deque": "cpp",
            "forward_list": "cpp",
            "list": "cpp",
            "unordered_map": "cpp",
            "unordered_set": "cpp",
            "vector": "cpp",
        },
        "python.analysis.extraPaths": [
            "/opt/ros/melodic/lib/python2.7/dist-packages"
        ],
        "editor.fontFamily": "'Droid Sans Mono', 'monospace', 'Droid Sans Fallback'"
    }

该文件用于对VScode进行页面风格、代码格式、字体颜色和大小等进行设置。其中：

①
"python.autoComplete.extraPaths"用于Python添加代码补全功能，其中路径为本地Python路径。

② "files.associations"用于配置文件关联，
有点类似C++中的宏定义，简单来讲"cctype":
"cpp"该语句将任何尾缀为cctype的文件被认为是cpp文件，VScode会用cpp规则匹配cpp文件做相应格式化，代码提示等。

③
"python.analysis.extraPaths"用于添加Python自定义模块的路径，注意的是该路径是相对于工作空间根目录的。

④ "editor.fontFamily"用于设置字体。

tasks.json文件中的内容如下所示

    {
        "version": "2.0.0",
        "tasks": [
            {
                "type": "shell",
                "label": "ROS: catkin_make",
                "command": "catkin_make",
                "args": [
                    "-j8",
                    "-DCMAKE_BUILD_TYPE=Debug"
                ],
                "options": {
                    "cwd": "${workspaceFolder}"
                },
                "problemMatcher": [
                    "$gcc"
                ],
                "group": "build",
                "detail": "调试器生成的任务。"
            },
        ],
    }

launch.json文件中的内容如下所示

    {
        "version": "0.2.0",
        "configurations": [
            {
                "name": "(gdb) 启动",
                "type": "cppdbg",
                "request": "launch",
                "program": "${workspaceFolder}/devel/lib/${input:package}/${input:program}",
                "args": [],
                "stopAtEntry": true,
                "cwd": "${workspaceFolder}",
                "environment": [],
                "externalConsole": false,
                "MIMode": "gdb",
                "sourceFileMap": {
                    "/build/glibc-S9d2JN": "/usr/src/glibc"
                },
                "setupCommands": [
                    {
                        "description": "为 gdb 启用整齐打印",
                        "text": "-enable-pretty-printing",
                        "ignoreFailures": true
                    },
                    {
                        "description": "将反汇编风格设置为 Intel",
                        "text": "-gdb-set disassembly-flavor intel",
                        "ignoreFailures": true
                    }
                ]
            }
        ],
        "inputs": [
            {
                "id": "package",
                "type": "promptString",
                "description": "Package name",
                "default": "learning_topic"
            },
            {
                "id": "program",
                "type": "promptString",
                "description": "Program name",
                "default": "turtle_publisher"
            }
        ]
    }

这两类文件直接照着填入即可，所以这里不对其进行过多讲述。


